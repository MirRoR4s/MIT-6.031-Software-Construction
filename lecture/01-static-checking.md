
# [静态检查](https://web.mit.edu/6.031/www/sp21/classes/01-static-checking/)阅读总结

## 学习目标

本篇文章包含以下两个主题：

- 静态类型
- 好的软件应具有的三大性质

---

## 类型

Python和 Java 代码之间最重要的语义差别在于变量的声明。Java 在声明变量时指定了变量的类型。

类型 = 一些值 + 可对这些值进行的一些操作。

Java 有一些原始数据类型，包括：

- `int`：表示 5 和 200 这样的整数，范围大概在 $\pm 2^{31}$ 之间
- `long`：表示更大的整数，范围大概在 $\pm 2^{63}$ 之间
- `boolean`：表示 true 或 false，即真和假
- `double`：表示浮点数，是实数的一个子集
- `char`：表示 `'A'` 或 `'$'` 这样的单个字符

Java 也有**对象类型**，比如：

- `string` 表示一个字符序列，类似于 python 的字符串。

- `BigInteger` 表示一个任意大小的整数，类似于 python 的整数。

根据 Java 惯例，原始类型小写，对象类型首字母大写。

**操作**（**Operations**）就是一种接收输入然后产生输出的函数（数学上的）（有时也会改变输入本身）。同一操作可能会有不同的语法，但无论它们的编写方式如何，我们都可将它们视为函数。以下是 Python 或 Java 中某操作的三种不同语法形式：

- 作为运算符。举个例子，`a + b` 执行了操作 `+ : int x int -> int`。（在该操作中，`+` 是操作的名称，箭头前的 `int x int` 描述了操作的两个输入，箭头后的 `int` 描述了操作的输出。）

- 作为对象的方法。举个例子，`bigint1.add(bigint2)` 调用了操作 `add: BigInteger x BigInteger -> BigInteger`。

- 作为函数。举个例子，`Math.sin(theta)` 调用了操作 `sin: double -> double`。此处的 `Math` 并不是一个对象，而是一个包含了 `sin` 函数的类。

对比一下 Java 的 `str.length()` 和 python 的 `len(str)`，它们实际上对应相同的操作——一个接收字符串并返回其长度的函数，但有不同的语法。

一些操作是可以重载的，在这样的情况下，同一操作名被用于不同的类型。Java 的原始数字类型大量重载了 `+`，`-`，`*`，`/` 。（比如 int 和 double 都用 `*` 表示乘法运算）算术运算符。方法也可被重载，并注意到大部分的编程语言都有一定程度的重载。

---

## 静态类型

Java 是一种**静态类型**的语言，所有变量的类型在编译时（即程序运行之前）就已知晓，所以编译器可以推断出所有表达式的类型。如果 `a`、`b` 都被声明为 `int`，那么编译器就可以推断出 `a+b` 也是 `int。`

在像 python 这样的**动态类型语言**中，这种检查被推迟到运行时进行。（即程序运行的时候）

静态类型（Static typing）是一种特殊的**静态检查**（static checking,），会在编译时就检查 bug 的存在。静态类型可预防将操作应用于错误类型的参数而产生的bug，如果你编写了一个如下的代码：

```java
"5" * "6"
```

该代码尝试将两个字符串相乘，当你还在编程时，静态类型就会捕获到该错误，而无需等到执行该代码时。

---

### 在动态类型语言中添加静态类型

尽管 python 是一种动态类型的语言，但在 python 3.5 之后的版本，可在代码中声明[类型提示](https://www.python.org/dev/peps/pep-0484/)（type hints）以指定变量和返回值的类型，如下所示：

```python
# Python function declared with type hints
def hello(name:str)->str:
    return 'Hi, ' + name
```

类似于 [Mypy](http://mypy-lang.org/) 这样的检查工具可在不运行代码的情况下利用声明的类型来静态地寻找类型错误。

其他动态类型的语言也有类似的扩展。比如为 JavaScript 语言添加静态类型扩展就创造了 [TypeScript](https://www.typescriptlang.org/)语言，具体如下所示：

```javascript
// TypeScript function
function hello(name:string):string {
    return 'Hi, ' + name;
}
```

为这些动态类型语言添加静态类型，反映了一种在软件工程师中广泛传播的理念即静态类型的使用对于构建和维护大型软件系统来说是很重要的。对比于像 Java 这样的静态类型语言，为一种动态类型语言添加静态类型创造了一种名为[渐进式类型化](https://en.wikipedia.org/wiki/Gradual_typing)（gradual typing）的编程方法，该方法在代码的某些部分添加静态类型声明，而其他部分则略去。渐进式类型化可为一个小的试验原型逐步演变为为一个大型、稳定、可维护的系统提供更光滑的路径。

---

## 静态检查，动态检查，无检查

可将编程语言提供的自动化检查分为如下三类：

- 静态检查（Static checking）：在程序运行之前自动发现 bug。

- 动态检查（Dynamic checking）：当代码执行时自动发现 bug。

- 无检查（No checking）：编程语言完全不帮你寻找错误。你必须自己寻找 bug 或是最终得到错误的结果。

静态捕获 bug 比动态捕获 bug 要好，而动态捕获 bug 又比完全不捕获 bug 要好。

**静态检查**可以捕获：

- 语法错误，例如多余的标点符号或关键字用法不当。即使是像 Python 这样的动态类型语言也会进行此类检查。如果你在 Python 程序中有一个缩进错误，那么在你开始运行程序之前就可以发现它。
- 拼写错误，例如 `Math.sine(2)`，正确的写法是 `sin`。
- 参数个数错误，例如 `Math.sin(30, 20)`。
- 参数类型错误，例如 `Math.sin("30")`。
- 返回类型错误，比如一个声明了返回类型为 `int` 的函数却返回了 `"30"`。

**动态检查**可以捕获：

- 非法参数值。例如，整数表达式 `x/y` 仅当 `y` 为零时才会产生错误；对于其他的 `y` 值，表达式的值是有明确定义的，所以在这个表达式中，除数为零不是一个静态错误，而是一个动态错误。
- 非法转换，即当特定值无法被转换或表示成目标值时。例如，`Integer.valueOf("hello")` 是一个动态错误，因为字符串 `"hello"` 无法被解析为一个十进制整数。对 `Integer.valueOf("800000000")` 来说也是如此，因为在 Java 中 800000000 超出了 `int` 能够表示的范围。
- 索引越界，例如使用了负数或是一个超大的数来索引字符串。
- 在 `null` 对象引用上调用一个方法（`null` 类似于 Python 的 `None`）

静态检查可以检测到和变量的类型相关联的错误，但通常情况下无法发现和该类型相关的特定值的错误。静态类型保证了一个变量必定具有来自其类型的某个值，但我们只有在运行的时候才可以确切地知道这个值是什么，所以如果错误是由特定值引起的，比如除数为零或是索引越界，那么编译器将不会抛出一个关于它的静态错误。

相反地，动态检查往往能够发现和特定值造成的错误。

---

### 原始类型并不是真正的数字

在 Java 和其他许多编程语言中都有这样一个问题：原始数值类型的边界情况与我们日常使用的整数和实数具有不同的行为，这导致的后果是一些本应被动态检查到的错误没有被检查到。如下是一些具体示例：

- **整数除法**。`5/2` 不返回一个分数，而是返回一个截断了小数部分的整数。这是一个我们期望产生动态错误的例子（因为分数不可以被表示成整数-非法转换），而非产生一个错误的结果。
- **整数溢出**（Integer overflow）。`int` 和 `long` 这两种类型实际上是一个有限的整数集合，其有最大值和最小值。当用这两种类型进行计算，并且结果的大小超出了集合的范围，就会发生溢出，然后从集合的有效范围中返回一个整数值，注意这通常不是正确的结果。
- **浮点类型中的特殊值**。像 `double` 这样的浮点类型有一些不为实数的特殊值：`NaN`（表示 "Not a Number"），`POSITIVE_INFINITY`，`NEGATIVE_INFINITY`。当对一个 double 变量执行了某种操作，但该操作的除数为零或是求取了负数的平方根，那么就会得到上述的特殊值。（这就是问题所在，本应产生动态错误却产生了上述的特殊值）如果继续用得到的结果进行后续的计算，那么最终就会得到一个错误的答案。

---

## 数组和集合（collections）

修改前面计算冰雹序列的代码，将序列存储在一个数据结构中，而不是直接打印它。Java 有两种类似于列表的类型可供我们使用：数组（arrays）和 列表（Lists）。

类似于整数，arrays（数组）是一种定长的序列类型。举个例子，以下代码演示了如何声明一个数组变量并对其进行赋值：

```java
int[] a = new int[100];
```

`int[]` 数组类型包括了所有可能的数组值，注意一个特定的数组值一旦被创建，其长度就再也不可以更改。对数组类型的操作包括：

- 索引：`a[2]`
- 赋值：`a[2] = 0`
- 获取长度：`a.length`

注意到 `a.length` 的语法和 `String.length()` 是不同的。因为 `a.length` 是一个实例变量，而非方法调用，所以不能在它后面加上括号。

下面是使用数组完成计算冰雹序列的代码。我们首先构造一个数组，然后利用索引变量 i 来遍历它。当我们生成一个序列项时就将其存放到数组中。

```java
int[] a = new int[100];  // <==== DANGER, WILL ROBINSON!
int i = 0;
int n = 3;
while (n != 1) {
    a[i] = n;
    i++;  // very common shorthand for i=i+1
    if (n % 2 == 0) {
        n = n / 2;
    } else {
        n = 3 * n + 1;
    }
}
a[i] = n;
i++;
```

上述代码存在一个问题，如果冰雹序列的长度超过了 100，那么我们声明的数组（长度为 100）将无法容纳下该序列，所以代码存在一个 bug。Java 能够捕获到该 bug 吗？

所以我们最好使用 `List`（列表） 类型，而不是定长的数组类型。列表是一种变长的序列类型。以下代码演示了如何声明一个 `List` 类型的变量 list。

```java
List<Integer> list = new ArrayList<Integer>();
```

List 类型支持的操作如下：

- 索引：`list.get(2)`
- 赋值：`list.set(2,0)`
- 获取长度：`list.size()`

为什么代码左侧是 `List`，但右侧却是 `ArrayList` 呢？`List` 实际上是一个接口，这是一种无法直接构造的类型，但它指定了一个 `List` 必须提供的操作，比如 `get()`、`set()`、`size()` 等等。`ArrayList` 是一个类，这是一个具体的类型，提供了上述操作的具体实现。`ArrayList` 并不是 `List` 类型的唯一实现，`LinkedList` 同样也实现了 `List`。当我们在声明变量或返回值的类型时，我们倾向于使用 List，因为这会使得代码更加的通用和灵活，而无需关心具体使用了哪种类型的列表。

可以在 Java 的 API 文档中查看所有 `List` 支持的操作或是 `ArrayList` 和 `LinkedList` 的具体信息：使用 web 搜索 “Java 15 API”。

> 最好了解一下 Java 的 API 文档，它们是你的朋友。（API 的意思是应用程序编程接口，此处指的是 Java 提供给我们的用于构建 Java 应用的类和方法）

为什么代码是 `List<Integer>`，而不是 `List<int>`？因为 Java 不允许我们这么编写代码。List 只知道如何处理对象类型，而不知道如何处理原始类型。每个原始类型都有一个等价的对象类型。比如和 int 等价的对象类型是 `Integer`，和 long 等价的对象类型是 `Long`，和 float 等价的对象类型是 `Float`，和 double 等价的对象类型是 `Double`。当我们用一种类型来参数化另一种类型时，Java 要求我们使用这些类型等价的对象类型。但在其他的情况下，Java 会自动地进行 `int` 和 `Integer` 的转换，所以我们可以直接编写 `Integer i = 5` 而不会引发类型错误。

以下是用列表类型对计算冰雹序列代码的重写：

```java
List<Integer> list = new ArrayList<Integer>();
int n = 3;
while (n != 1) {
    list.add(n);
    if (n % 2 == 0) {
        n = n / 2;
    } else {
        n = 3 * n + 1;
    }
}
list.add(n);
```

上述代码不仅更加简单，而且还更加安全，因为 list 列表会自动扩容以存放我们添加的数字(当前，也不可能无限地扩容，当内存耗尽时就会停止)。

## 迭代

与 python 一样，for 循环可以用来遍历数组或列表中的元素，不过 java 的语法稍微有些不同，具体如下：

```java
// find the maximum point of a hailstone sequence stored in list
int max = 0;
for (int x : list) {
    max = Math.max(x, max);
}
```

遍历数组的方式和遍历列表一样，你只需要把列表换成数组即可。

> `Math.max()` 是一个来自 Java API 的函数。Math 类有很多像这样的实用函数——web 搜索 “Java 15 Math” 可以找到相关的文档。

## 方法

在 Java 中，语句通常在方法中，而每个方法都必须要在一个类中，所以编写冰雹程序最简单的方式看起来应是如下的样子：

```java
public class Hailstone {
    /**
     * Compute a hailstone sequence.
     * @param n  starting number for sequence; assumes n > 0.
     * @return hailstone sequence starting with n and ending with 1.
     */
    public static List<Integer> hailstoneSequence(int n) {
        List<Integer> list = new ArrayList<Integer>();
        while (n != 1) {
            list.add(n);
            if (n % 2 == 0) {
                n = n / 2;
            } else {
                n = 3 * n + 1;
            }
        }
        list.add(n);
        return list;
    }
}
```

解释一下上述代码：

`public` 意味着程序中的任何代码都可以引用该类或方法。其他的访问修饰符，比如说 `private` 用于在程序中获得更高的安全性以及保证不可变类型的不可变性。

`static` 意味着该方法是一个没有 `self` 参数的函数。（`self` 在 Java 中被称为 `this`，并且是隐式传递的，所以你不会显式地看到它作为一个方法的参数）与 `List.add()` 或 `String.length()` 这两个需要一个对象的方法不同，`static` 方法不是在一个对象上调用的。调用一个 `static` 方法的正确方式是使用类名而非对象引用：`Hailstone.hailstoneSequence(83)`。

注意方法上方的蓝色注释 `/** ... */`。注释是方法的规范，描述了操作的输入和输出，规范应该要简洁、清晰、精确。

方法注释提供了从方法的类型声明中无法知晓的信息。例如尽管它没有说明 `n` 是一个整数（因为下方的 `int n` 已经说明了这一点），但它说到 `n` 必须是一个正数，这个信息并没有在类型声明中体现出来，但对于方法的调用者来说，这却是一个必须要知道的非常重要的信息。

## 可变值（Mutating values） vs. 可重赋值变量（reassigning variables）

改变是必要之恶，但是好的程序员尝试避免变化的事物，因为事物的变化是不可预料的。不可变性——人为地禁止特定事物在运行时改变（本门课程主要设计原则）。

不可变类型（immutable type）：一旦创建后值就再也不能改变的类型。`string` 类型在 Python 和 Java 中都是不可变的。

不可变引用：一旦赋值后就再也不可以重新赋值的变量。为了创建一个不可重新赋值的引用，可以用 `final` 关键字来声明它，如下代码所示：

```java
final int n = 5;
```

如果 Java 编译器不相信你的 `final` 变量在运行时仅会被赋值一次，那么编译器就会产生一个编译错误，所以 `final` 关键字可以用来对不可重新赋值的引用进行静态检查。

将方法的参数声明为 `final` 并尽可能地使用局部变量是一种好的实践。和变量的类型一样，这些声明是重要的记录，对代码的阅读者和编译器的静态检查来说十分有用。

---

## 记录假设

写下一个变量的类型，并记录下有关该变量的假设，比如变量总引用一个整数。Java 实际上会在编译时检查该假设，并保证你的程序没有违反它。

将一个变量声明为 `final` 也是某种记录形式。这实际上是一种宣称：变量在初始赋值后就再也不会被重新赋值，Java 也会静态地检查这种情况。

我们还记录下了 Java 不会自动检查的另一个假设：`n` 必须是正数。

为什么需要写下我们的假设呢？因为程序中充满了假设，如果我们不写下它们，那么我们将很快忘记。并且以后其他需要阅读或修改我们程序的人也无法知晓这些假设，所以它们只能猜测。

在编写程序时需要牢记以下两个目标：

- 和计算机交流。首先让编译器相信你的程序是合理的——语法正确以及类型正确。然后使程序在逻辑上是正确的，以便在运行时能够得到正确的结果。
- 和其他人交流。使程序易于理解，以便他人可以在未来修复、改进或采用你的代码。

---

## 6.031 的目标

学习如何开发出具备以下三种属性的软件：

- 不易受到 bug 的侵扰（Safe from bugs）。软件必须具备正确性（当前具有正确的行为）和防御性（未来也具有正确的行为）
- 易于理解（Easy to understand）。
- 适应变化（Ready for change）。软件总在变化，好的设计可以使变化更容易，然而糟糕的设计却需要摒弃之前的实现并重写大量代码。

好的软件还有许多其它重要的属性，如性能、可用性、安全性等。但 6.031 主要关注上述三种，这也是大多数开发者构建软件时首先考虑的。

要思考在本门课程中学习到的语言特性、编程实践、设计模式，并理解它们和上述三大属性的联系。

## 总结

静态检查和三大属性的关联点：

- 静态检查通过在代码执行前捕获类型错误或其它 bug 来使代码更加 Safe from bugs。
- 静态检查通过显式地声明变量的类型从而使得代码更加易于理解（Easy to understand）
- 静态检查通过标出那些需要修改的地方从而使得代码更加 Ready for change。比如当修改了一个变量的类型或名字，编辑器立马就会在所有使用了该变量的地方显示错误，提醒你修复它们。
